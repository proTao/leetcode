from pprint import pprint
from collections import Counter

class Solution:
    def findMaxForm(self, strs, m, n):
        """
        :type strs: List[str]
        :type m: int of 0
        :type n: int of 1
        :rtype: int
        """

        prices = [(s.count("0"),s.count("1")) for s in strs]
        prices = Counter(prices)

        # dp iniitial
        dp = [[0] * (n+1) for i in range(m+1)]
        

        def zeroOnePack2D(c0, c1, w=1):
            for i in range(m, c0-1, -1):
                for j in range(n, c1-1, -1):
                    dp[i][j] = max(dp[i][j], dp[i-c0][j-c1] + w)

        def completePack2D(c0, c1, w=1):
            for i in range(c0, m+1):
                for j in range(c1, n+1):
                    dp[i][j] = max(dp[i][j], dp[i-c0][j-c1] + w)

        def multiplePack2D(c0, c1, max_buy, w=1):
            if c0 * max_buy >= m and c1 * max_buy >= n:
                completePack2D(c0, c1, w)
            else:
                k = 1
                while k < max_buy:
                    zeroOnePack2D(k * c0, k * c1, w * k)
                    max_buy = max_buy - k
                    k *= 2
                if max_buy > 0:
                    zeroOnePack2D(c0*max_buy, c1*max_buy, w * max_buy)

        for c, max_buy in prices.items():
            multiplePack2D(c[0], c[1], max_buy)
        return dp[-1][-1]

    def naiveFindMaxForm(self, strs, m, n):
        """
        :type strs: List[str]
        :type m: int of 0
        :type n: int of 1
        :rtype: int
        """
        def count01(s):
            l = len(s)
            _0 = s.count("0")
            return (_0, l - _0)

        prices = [count01(i) for i in strs]

        # dp iniitial
        dp = [[0] * (n+1) for i in range(m+1)]

        # naive multiple Pack Problem
        # print(dp)

        
        for item in prices:
            # print(item)
            for i in range(m, item[0]-1, -1):
                for j in range(n, item[1]-1, -1):
                    dp[i][j] = max(dp[i][j], dp[i-item[0]][j-item[1]] + 1)
        return dp[-1][-1]

class StandardSolution:
    def getMax(self, arr, m, n):
        res = 0

        for e in arr:
            if m >= e[0] and n >= e[1]:
                res += 1
                m -= e[0]
                n -= e[1]
                print((m,n),end=" ")
            else:
                print("pass", end=" ")
        print(res)

        return res

    def findMaxForm(self, strs, m, n):
        """
        :type strs: List[str]
        :type m: int
        :type n: int
        :rtype: int
        """
        arr = [(s.count('0'), s.count('1')) for s in strs]
	
        # 按照选择之后的背包剩余量的较小值升序排列，即优先选择剩的多的
        arr1 = sorted(arr, key=lambda s: min(m - s[0], n - s[1]), reverse=True)
        print(arr1)
        
        # 按照较小代价升序排列，即优先选择较小代价
        arr2 = sorted(arr, key=lambda s: min(s[0], s[1]))
        print(arr2)
        res = max(self.getMax(arr1, m, n), self.getMax(arr2, m, n))

        return res


ss=["1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101"]
m=100
n=100

ss=["111","1000","1000","1000"]
m=9
n=3

# ss= ["10", "1", "0"]
# m = 1
# n = 1

print(StandardSolution().findMaxForm(ss, m,n))
# print("="*100)
# print(Solution().naiveFindMaxForm(ss, m,n))
